An Alpha virtual machine has 4 usable registers.
They are all 32 bits wide.
Register name         Use
R0                    Accumulator
R1		      General-purpose
R2		      Stack pointer
R3		      Program counte
There is also a 32-bit status register
Byte ordering is big-endian.
Registers are numbered 0 to 3.
Registers are specified with 2 bits
AA represents the source while BB represents the destination
Instruction set:
==Memory==
0b00 00 AA BB: Register-to-register copy
0b00 01 AA BB: Register-to-memory copy
0b00 10 AA BB: Memory-to-register copy
0b00 11 00 BB: Load next 4 bytes to BB
==Flow control== There is no need for an unconditional jump, just load into R3!
0b01 00 AA BB: If R0==AA then jump to BB
0b01 01 AA BB: If R0!=AA then jump to BB
0b01 10 AA BB: If R0<AA then jump to BB
0b01 11 AA BB: If R0>AA then jump to BB
==Stack==
0b10 00 00 AA: Push AA
0b10 00 01 BB: Pop into BB
==Arithmetic==
0b10 00 10 AA: Add AA [to R0]
0b10 00 11 AA: Subtract AA
0b10 01 00 AA: Multiply AA
0b10 01 01 AA: Divide AA
0b10 01 10 AA: Modulo AA
0b10 01 11 AA: Decrement AA
0b10 10 00 AA: Increment AA
==Other==
0b11 00 00 00: Print R0 in decimal
0b11 00 01 01: Load the memory size into R0
0b11 00 10 AA: Push R3 onto the stack, jump to AA (call)
0b11 00 11 AA: Jump and pop address on top of stack (return)
0b11 01 00 00: Halt execution, return R0 to the OS
0b11 01 01 AA: Decrement R0, jump to AA if R0!=0 (Z80 DJNZ)
0b11 01 10 AA: Print null-terminated string at AA [unimplemented]